// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse, RequestConfig } from '../../http/types';
import { RequestBuilder } from '../../http/transport/request-builder';
import { SerializationStyle } from '../../http/serialization/base-serializer';
import { CreateCollectionFolder, createCollectionFolderResponse } from './models/create-collection-folder';
import {
  CreateCollectionRequestOkResponse,
  createCollectionRequestOkResponseResponse,
} from './models/create-collection-request-ok-response';
import {
  CreateCollectionRequestParams,
  CreateCollectionResponseParams,
  GetCollectionFolderParams,
  GetCollectionRequestParams,
  GetCollectionResponseParams,
} from './request-params';
import { CreateCollectionResponse, createCollectionResponseResponse } from './models/create-collection-response';
import { GetCollectionFolder, getCollectionFolderResponse } from './models/get-collection-folder';
import { UpdateCollectionFolder, updateCollectionFolderResponse } from './models/update-collection-folder';
import { DeleteCollectionFolder, deleteCollectionFolderResponse } from './models/delete-collection-folder';
import { GetCollectionRequest, getCollectionRequestResponse } from './models/get-collection-request';
import { UpdateCollectionRequest, updateCollectionRequestResponse } from './models/update-collection-request';
import { DeleteCollectionRequest, deleteCollectionRequestResponse } from './models/delete-collection-request';
import { GetCollectionResponse, getCollectionResponseResponse } from './models/get-collection-response';
import { UpdateCollectionResponse, updateCollectionResponseResponse } from './models/update-collection-response';
import { DeleteCollectionResponse, deleteCollectionResponseResponse } from './models/delete-collection-response';

export class CollectionItemsService extends BaseService {
  /**
 * Creates a folder in a collection. For a complete list of properties, refer to "Folder" in the [collection.json schema file](https://schema.postman.com/collection/json/v2.1.0/draft-07/collection.json).
You can use this endpoint to to import requests and responses into a newly-created folder. To do this, include the `requests` field and the list of request objects in the request body. For more information, see the provided example.

**Note:**

It is recommended that you pass the `name` property in the request body. If you do not, the system uses a null value. As a result, this creates a folder with a blank name.

 * @param {string} collectionId - The collection's ID.
 * @returns {Promise<HttpResponse<CreateCollectionFolder>>} Successful Response
 */
  async createCollectionFolder(
    collectionId: string,
    body: any,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<CreateCollectionFolder>> {
    const request = new RequestBuilder<CreateCollectionFolder>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('POST')
      .setPath('/collections/{collectionId}/folders')
      .setRequestSchema(z.any())
      .setResponseSchema(createCollectionFolderResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<CreateCollectionFolder>(request);
  }

  /**
 * Creates a request in a collection. For a complete list of properties, see the [Collection Format Request documentation](https://learning.postman.com/collection-format/reference/request/).
**Note:**

It is recommended that you pass the `name` property in the request body. If you do not, the system uses a null value. As a result, this creates a request with a blank name.

 * @param {string} collectionId - The collection's ID.
 * @param {string} [folderId] - The folder ID in which to create the request. By default, the system will create the request at the collection level.
 * @returns {Promise<HttpResponse<CreateCollectionRequestOkResponse>>} Successful Response
 */
  async createCollectionRequest(
    collectionId: string,
    body: any,
    params?: CreateCollectionRequestParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<CreateCollectionRequestOkResponse>> {
    const request = new RequestBuilder<CreateCollectionRequestOkResponse>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('POST')
      .setPath('/collections/{collectionId}/requests')
      .setRequestSchema(z.any())
      .setResponseSchema(createCollectionRequestOkResponseResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addQueryParam({
        key: 'folderId',
        value: params?.folderId,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<CreateCollectionRequestOkResponse>(request);
  }

  /**
 * Creates a request response in a collection. For a complete list of request body properties, see the [Collection Format Response documentation](https://learning.postman.com/collection-format/reference/response/#reference-diagram).
**Note:**

It is recommended that you pass the `name` property in the request body. If you do not, the system uses a null value. As a result, this creates a response with a blank name.

 * @param {string} collectionId - The collection's ID.
 * @param {string} requestId - The parent request's ID.
 * @returns {Promise<HttpResponse<CreateCollectionResponse>>} Successful Response
 */
  async createCollectionResponse(
    collectionId: string,
    body: any,
    params: CreateCollectionResponseParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<CreateCollectionResponse>> {
    const request = new RequestBuilder<CreateCollectionResponse>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('POST')
      .setPath('/collections/{collectionId}/responses')
      .setRequestSchema(z.any())
      .setResponseSchema(createCollectionResponseResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addQueryParam({
        key: 'requestId',
        value: params?.requestId,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<CreateCollectionResponse>(request);
  }

  /**
   * Gets information about a folder in a collection.
   * @param {string} folderId - The folder's ID.
   * @param {string} collectionId - The collection's ID.
   * @param {boolean} [ids] - If true, returns only properties that contain ID values in the response.
   * @param {boolean} [uid] - If true, returns all IDs in UID format (`userId`-`id`).
   * @param {boolean} [populate] - If true, returns all of the collection item's contents.
   * @returns {Promise<HttpResponse<GetCollectionFolder>>} Successful Response
   */
  async getCollectionFolder(
    folderId: string,
    collectionId: string,
    params?: GetCollectionFolderParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<GetCollectionFolder>> {
    const request = new RequestBuilder<GetCollectionFolder>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('GET')
      .setPath('/collections/{collectionId}/folders/{folderId}')
      .setRequestSchema(z.any())
      .setResponseSchema(getCollectionFolderResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'folderId',
        value: folderId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addQueryParam({
        key: 'ids',
        value: params?.ids,
      })
      .addQueryParam({
        key: 'uid',
        value: params?.uid,
      })
      .addQueryParam({
        key: 'populate',
        value: params?.populate,
      })
      .build();
    return this.client.call<GetCollectionFolder>(request);
  }

  /**
 * Updates a folder in a collection. For a complete list of properties, refer to "Folder" in the [collection.json schema file](https://schema.postman.com/collection/json/v2.1.0/draft-07/collection.json).
**Note:**

This endpoint acts like a PATCH method. It only updates the values that you pass in the request body (for example, the `name` property). The endpoint does not update the entire resource.

 * @param {string} folderId - The folder's ID.
 * @param {string} collectionId - The collection's ID.
 * @returns {Promise<HttpResponse<UpdateCollectionFolder>>} Successful Response
 */
  async updateCollectionFolder(
    folderId: string,
    collectionId: string,
    body: any,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<UpdateCollectionFolder>> {
    const request = new RequestBuilder<UpdateCollectionFolder>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('PUT')
      .setPath('/collections/{collectionId}/folders/{folderId}')
      .setRequestSchema(z.any())
      .setResponseSchema(updateCollectionFolderResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'folderId',
        value: folderId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<UpdateCollectionFolder>(request);
  }

  /**
   * Deletes a folder in a collection.
   * @param {string} folderId - The folder's ID.
   * @param {string} collectionId - The collection's ID.
   * @returns {Promise<HttpResponse<DeleteCollectionFolder>>} Successful Response
   */
  async deleteCollectionFolder(
    folderId: string,
    collectionId: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<DeleteCollectionFolder>> {
    const request = new RequestBuilder<DeleteCollectionFolder>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('DELETE')
      .setPath('/collections/{collectionId}/folders/{folderId}')
      .setRequestSchema(z.any())
      .setResponseSchema(deleteCollectionFolderResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'folderId',
        value: folderId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .build();
    return this.client.call<DeleteCollectionFolder>(request);
  }

  /**
   * Gets information about a request in a collection.
   * @param {string} requestId - The request's ID.
   * @param {string} collectionId - The collection's ID.
   * @param {boolean} [ids] - If true, returns only properties that contain ID values in the response.
   * @param {boolean} [uid] - If true, returns all IDs in UID format (`userId`-`id`).
   * @param {boolean} [populate] - If true, returns all of the collection item's contents.
   * @returns {Promise<HttpResponse<GetCollectionRequest>>} Successful Response
   */
  async getCollectionRequest(
    requestId: string,
    collectionId: string,
    params?: GetCollectionRequestParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<GetCollectionRequest>> {
    const request = new RequestBuilder<GetCollectionRequest>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('GET')
      .setPath('/collections/{collectionId}/requests/{requestId}')
      .setRequestSchema(z.any())
      .setResponseSchema(getCollectionRequestResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'requestId',
        value: requestId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addQueryParam({
        key: 'ids',
        value: params?.ids,
      })
      .addQueryParam({
        key: 'uid',
        value: params?.uid,
      })
      .addQueryParam({
        key: 'populate',
        value: params?.populate,
      })
      .build();
    return this.client.call<GetCollectionRequest>(request);
  }

  /**
 * Updates a request in a collection. For a complete list of properties, see the [Collection Format Request documentation](https://learning.postman.com/collection-format/reference/request/).
**Note:**

- You must pass a collection ID (`12ece9e1-2abf-4edc-8e34-de66e74114d2`), not a collection(`12345678-12ece9e1-2abf-4edc-8e34-de66e74114d2`), in this endpoint.
- This endpoint does not support changing the folder of a request.

 * @param {string} requestId - The request's ID.
 * @param {string} collectionId - The collection's ID.
 * @returns {Promise<HttpResponse<UpdateCollectionRequest>>} Successful Response
 */
  async updateCollectionRequest(
    requestId: string,
    collectionId: string,
    body: any,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<UpdateCollectionRequest>> {
    const request = new RequestBuilder<UpdateCollectionRequest>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('PUT')
      .setPath('/collections/{collectionId}/requests/{requestId}')
      .setRequestSchema(z.any())
      .setResponseSchema(updateCollectionRequestResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'requestId',
        value: requestId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<UpdateCollectionRequest>(request);
  }

  /**
   * Deletes a request in a collection.
   * @param {string} requestId - The request's ID.
   * @param {string} collectionId - The collection's ID.
   * @returns {Promise<HttpResponse<DeleteCollectionRequest>>} Successful Response
   */
  async deleteCollectionRequest(
    requestId: string,
    collectionId: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<DeleteCollectionRequest>> {
    const request = new RequestBuilder<DeleteCollectionRequest>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('DELETE')
      .setPath('/collections/{collectionId}/requests/{requestId}')
      .setRequestSchema(z.any())
      .setResponseSchema(deleteCollectionRequestResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'requestId',
        value: requestId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .build();
    return this.client.call<DeleteCollectionRequest>(request);
  }

  /**
   * Gets information about a response in a collection.
   * @param {string} responseId - The response's ID.
   * @param {string} collectionId - The collection's ID.
   * @param {boolean} [ids] - If true, returns only properties that contain ID values in the response.
   * @param {boolean} [uid] - If true, returns all IDs in UID format (`userId`-`id`).
   * @param {boolean} [populate] - If true, returns all of the collection item's contents.
   * @returns {Promise<HttpResponse<GetCollectionResponse>>} Successful Response
   */
  async getCollectionResponse(
    responseId: string,
    collectionId: string,
    params?: GetCollectionResponseParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<GetCollectionResponse>> {
    const request = new RequestBuilder<GetCollectionResponse>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('GET')
      .setPath('/collections/{collectionId}/responses/{responseId}')
      .setRequestSchema(z.any())
      .setResponseSchema(getCollectionResponseResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'responseId',
        value: responseId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addQueryParam({
        key: 'ids',
        value: params?.ids,
      })
      .addQueryParam({
        key: 'uid',
        value: params?.uid,
      })
      .addQueryParam({
        key: 'populate',
        value: params?.populate,
      })
      .build();
    return this.client.call<GetCollectionResponse>(request);
  }

  /**
 * Updates a response in a collection. For a complete list of properties, see the [Collection Format Response documentation](https://learning.postman.com/collection-format/reference/response/#reference-diagram).
**Note:**

- You must pass a collection ID (`12ece9e1-2abf-4edc-8e34-de66e74114d2`), not a collection UID (`12345678-12ece9e1-2abf-4edc-8e34-de66e74114d2`), in this endpoint.
- This endpoint acts like a PATCH method. It only updates the values that you pass in the request body (for example, the `name` property). The endpoint does not update the entire resource.

 * @param {string} responseId - The response's ID.
 * @param {string} collectionId - The collection's ID.
 * @returns {Promise<HttpResponse<UpdateCollectionResponse>>} Successful Response
 */
  async updateCollectionResponse(
    responseId: string,
    collectionId: string,
    body: any,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<UpdateCollectionResponse>> {
    const request = new RequestBuilder<UpdateCollectionResponse>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('PUT')
      .setPath('/collections/{collectionId}/responses/{responseId}')
      .setRequestSchema(z.any())
      .setResponseSchema(updateCollectionResponseResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'responseId',
        value: responseId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<UpdateCollectionResponse>(request);
  }

  /**
   * Deletes a response in a collection.
   * @param {string} responseId - The response's ID.
   * @param {string} collectionId - The collection's ID.
   * @returns {Promise<HttpResponse<DeleteCollectionResponse>>} Successful Response
   */
  async deleteCollectionResponse(
    responseId: string,
    collectionId: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<DeleteCollectionResponse>> {
    const request = new RequestBuilder<DeleteCollectionResponse>()
      .setConfig(this.config)
      .setBaseUrl(this.config)
      .setMethod('DELETE')
      .setPath('/collections/{collectionId}/responses/{responseId}')
      .setRequestSchema(z.any())
      .setResponseSchema(deleteCollectionResponseResponse)
      .setRequestContentType(ContentType.Json)
      .setResponseContentType(ContentType.Json)
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'responseId',
        value: responseId,
      })
      .addPathParam({
        key: 'collectionId',
        value: collectionId,
      })
      .build();
    return this.client.call<DeleteCollectionResponse>(request);
  }
}
