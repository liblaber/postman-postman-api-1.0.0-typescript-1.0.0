// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse } from '../../http';
import { RequestConfig } from '../../http/types';
import {
  DetectedSecretsQueriesOkResponse,
  DetectedSecretsQueriesRequest,
  GetSecretTypes,
  GetSecretsLocations,
  UpdateDetectedSecretResolutionsOkResponse,
  UpdateDetectedSecretResolutionsRequest,
  detectedSecretsQueriesOkResponseResponse,
  detectedSecretsQueriesRequestRequest,
  getSecretTypesResponse,
  getSecretsLocationsResponse,
  updateDetectedSecretResolutionsOkResponseResponse,
  updateDetectedSecretResolutionsRequestRequest,
} from './models';
import { DetectedSecretsQueriesParams, GetDetectedSecretsLocationsParams } from './request-params';

export class SecretScannerService extends BaseService {
  /**
   * Returns all secrets detected by Postman's [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/), grouped by workspace. If you pass an empty request body, this endpoint returns all results.
   * @param {number} [limit] - The maximum number of rows to return in the response.
   * @param {string} [cursor] - The pointer to the first record of the set of paginated results. To view the next response, use the `nextCursor` value for this parameter.
   * @param {string} [include] - The additional fields to be included as a part of the request.
   * @returns {Promise<HttpResponse<DetectedSecretsQueriesOkResponse>>} Successful Response
   */
  async detectedSecretsQueries(
    body: DetectedSecretsQueriesRequest,
    params?: DetectedSecretsQueriesParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<DetectedSecretsQueriesOkResponse>> {
    const path = '/detected-secrets-queries';
    const options: any = {
      responseSchema: detectedSecretsQueriesOkResponseResponse,
      requestSchema: detectedSecretsQueriesRequestRequest,
      body: body as any,
      queryParams: {},
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.limit) {
      options.queryParams['limit'] = params?.limit;
    }
    if (params?.cursor) {
      options.queryParams['cursor'] = params?.cursor;
    }
    if (params?.include) {
      options.queryParams['include'] = params?.include;
    }
    return this.client.post(path, options);
  }

  /**
   * Updates the resolution status of a secret detected in a workspace.
   * @param {string} secretId - The secret's ID.
   * @returns {Promise<HttpResponse<UpdateDetectedSecretResolutionsOkResponse>>} Successful Response
   */
  async updateDetectedSecretResolutions(
    secretId: string,
    body: UpdateDetectedSecretResolutionsRequest,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<UpdateDetectedSecretResolutionsOkResponse>> {
    const path = this.client.buildPath('/detected-secrets/{secretId}', { secretId: secretId });
    const options: any = {
      responseSchema: updateDetectedSecretResolutionsOkResponseResponse,
      requestSchema: updateDetectedSecretResolutionsRequestRequest,
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.put(path, options);
  }

  /**
   * Gets the locations of secrets detected by Postman's [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/).
   * @param {string} secretId - The secret's ID.
   * @param {string} workspaceId - The workspace's ID.
   * @param {number} [limit] - The maximum number of rows to return in the response.
   * @param {string} [cursor] - The pointer to the first record of the set of paginated results. To view the next response, use the `nextCursor` value for this parameter.
   * @returns {Promise<HttpResponse<GetSecretsLocations>>} Successful Response
   */
  async getDetectedSecretsLocations(
    secretId: string,
    params: GetDetectedSecretsLocationsParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<GetSecretsLocations>> {
    const path = this.client.buildPath('/detected-secrets/{secretId}/locations', { secretId: secretId });
    const options: any = {
      responseSchema: getSecretsLocationsResponse,
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.limit) {
      options.queryParams['limit'] = params?.limit;
    }
    if (params?.cursor) {
      options.queryParams['cursor'] = params?.cursor;
    }
    if (params?.workspaceId) {
      options.queryParams['workspaceId'] = params?.workspaceId;
    }
    return this.client.get(path, options);
  }

  /**
   * Gets the metadata of the secret types supported by Postman's [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/). You can use a secret type's ID in the response to query data with the POST `/detected-secrets/{secretId}` endpoint.
   * @returns {Promise<HttpResponse<GetSecretTypes>>} Successful Response
   */
  async getSecretTypes(requestConfig?: RequestConfig): Promise<HttpResponse<GetSecretTypes>> {
    const path = '/secret-types';
    const options: any = {
      responseSchema: getSecretTypesResponse,
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }
}
